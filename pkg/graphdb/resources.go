package graphdb

import (
	"fmt"

	"github.com/neo4j/neo4j-go-driver/v4/neo4j"
)

type Resource = map[string]interface{}

type ResourceService interface {
	Save(name, kind string) (Resource, error)
	FindAll(page *Paging) ([]Resource, error)
	GetAppResources(appId string) ([]Resource, error)
	FindOneByName(name string) (Resource, error)
}

type neo4jResourceService struct {
	driver neo4j.Driver
}

func NewResourceService(driver neo4j.Driver) ResourceService {
	return &neo4jResourceService{driver: driver}
}

// Save should create a new Resource node in the database with the name
// provided and a `resourceId` property generated by the server.
//

func (as *neo4jResourceService) Save(name, kind string) (_ Resource, err error) {
	// Open a new Session
	session := as.driver.NewSession(neo4j.SessionConfig{})
	defer func() {
		err = DeferredClose(session, err)
	}()

	result, err := session.WriteTransaction(func(tx neo4j.Transaction) (interface{}, error) {
		result, err := tx.Run(`
			CREATE (u:Resource {
				  resourceId: randomUuid(),
				  name: $name,
				  kind: $kind
			})
			RETURN u { .resourceId, .name } as u`,
			map[string]interface{}{
				"name": name,
				"kind": kind,
			})

		// Extract safe properties from the user node (`u`) in the first row
		record, err := result.Single()

		// Handle Unique constraint errors in the database
		if neo4jError, ok := err.(*neo4j.Neo4jError); ok && neo4jError.Title() == "ConstraintValidationFailed" {
			return nil, NewDomainError(
				AlreadyExists,
				fmt.Sprintf("A resource already exists with the same name %s", name),
				map[string]interface{}{
					"name": "resource name taken",
				},
			)
		}

		// All other errors
		if err != nil {
			return nil, err
		}

		resource, _ := record.Get("u")
		return resource, nil
	})
	if err != nil {
		return nil, err
	}

	resource := result.(map[string]interface{})
	return resource, nil
}

// FindAll should return a paginated list of resources ordered by the `sort`
// parameter and limited to the number passed as `limit`.  The `skip` variable should be
// used to skip a certain number of rows.
//
func (ms *neo4jResourceService) FindAll(page *Paging) (_ []Resource, err error) {
	// Open a new Session
	session := ms.driver.NewSession(neo4j.SessionConfig{})

	// Close the session once this function has completed
	defer func() {
		err = DeferredClose(session, err)
	}()

	// Execute a query in a new Read Transaction
	results, err := session.ReadTransaction(func(tx neo4j.Transaction) (interface{}, error) {

		// Retrieve a list of resources
		sort := page.Sort()
		result, err := tx.Run(fmt.Sprintf(`
	MATCH (m:Resource)
	WHERE m.`+"`%[1]s`"+` IS NOT NULL
	RETURN m { .* } AS resource
	ORDER BY m.`+"`%[1]s`"+` %s
	SKIP $skip
	LIMIT $limit
	`, sort, page.Order()), map[string]interface{}{
			"skip":  page.Skip(),
			"limit": page.Limit(),
		})
		if err != nil {
			return nil, err
		}

		// Get a list of Resources from the Result
		records, err := result.Collect()
		if err != nil {
			return nil, err
		}
		var results []map[string]interface{}
		for _, record := range records {
			resource, _ := record.Get("resource")
			results = append(results, resource.(map[string]interface{}))
		}
		return results, nil
	})

	if err != nil {
		return nil, err
	}
	return results.([]Resource), nil
}

// getAppResources should return a list of resources that have
// the app has added to their Resources Access list.
func (ms *neo4jResourceService) GetAppResources(appId string) (_ []Resource, err error) {

	// Open a new Session
	session := ms.driver.NewSession(neo4j.SessionConfig{})

	// Close the session once this function has completed
	defer func() {
		err = DeferredClose(session, err)
	}()

	// Execute a query in a new Read Transaction
	results, err := session.ReadTransaction(func(tx neo4j.Transaction) (interface{}, error) {
		// If appId is not defined, return nil
		if appId == "" {
			return nil, nil
		}

		// Find Resources for App
		result, err := tx.Run(`
		MATCH (u:App {appId: $appId})-[:ACCESS]->(m)
		RETURN m { .* } AS resource
	`, map[string]interface{}{"appId": appId})

		if err != nil {
			return nil, err
		}

		// Get a list of Resources from the Result
		records, err := result.Collect()
		if err != nil {
			return nil, err
		}
		var results []map[string]interface{}
		for _, record := range records {
			resource, _ := record.Get("resource")
			results = append(results, resource.(map[string]interface{}))
		}
		return results, nil
	})

	if err != nil {
		return nil, err
	}
	return results.([]Resource), nil
}

// FindOneByName should find an Resource node in the database with the name
// provided by the caller
//
func (as *neo4jResourceService) FindOneByName(name string) (_ Resource, err error) {
	// Open a new Session
	session := as.driver.NewSession(neo4j.SessionConfig{})
	defer func() {
		err = DeferredClose(session, err)
	}()

	// Find the Resource node within a Read Transaction
	result, err := session.ReadTransaction(func(tx neo4j.Transaction) (interface{}, error) {
		result, err := tx.Run(`
			MATCH (u:Resource {name: $name}) RETURN u`,
			map[string]interface{}{
				"name": name,
			})
		if err != nil {
			return nil, err
		}

		record, err := result.Single()
		if neo4jError, ok := err.(*neo4j.UsageError); ok && neo4jError.Message == "Result contains no more records" {
			return nil, NewDomainError(
				NotFound,
				fmt.Sprintf("Resource with name %s not found", name),
				map[string]interface{}{
					"name": "resource not found",
				},
			)
		}

		if err != nil {
			return nil, err
		}

		resource, _ := record.Get("u")
		return resource, nil

	})

	if err != nil {
		return nil, err
	}

	resourceNode := result.(neo4j.Node)
	resource := resourceNode.Props

	return resource, nil
}
