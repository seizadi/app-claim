package graphdb

import (
"fmt"

"github.com/neo4j/neo4j-go-driver/v4/neo4j"

)

type App struct{
	AppId string
	Name string
	Stage string
	Environment string
	ShortName string
}

type AppService interface {
	Save(app App) (App, error)
	FindAll(page *Paging) ([]App, error)
	FindOneByName(name string) (App, error)
}

type neo4jAppService struct {
	driver     neo4j.Driver
	jwtSecret  string
	saltRounds int
}

func NewAppService(driver neo4j.Driver) AppService {
	return &neo4jAppService{
		driver:     driver,
	}
}
func resolveString(s interface{}) string {
	if str, ok := s.(string); ok {
		return str
	}
	return ""
}
func getApp(app map[string]interface{}) App {
	retApp := App{}
	retApp.AppId = resolveString(app["appId"])
	retApp.Name = resolveString(app["name"])
	retApp.Stage = resolveString(app["stage"])
	retApp.Environment = resolveString(app["environment"])
	retApp.ShortName = resolveString(app["shortName"])
	return retApp
}

// Save should create a new App node in the database with the name
// provided and a `appId` property generated by the server.
//
func (as *neo4jAppService) Save(app App) (_ App, err error) {
	retApp := App{}
	
	// Open a new Session
	session := as.driver.NewSession(neo4j.SessionConfig{})
	defer func() {
		err = DeferredClose(session, err)
	}()
	
	result, err := session.WriteTransaction(func(tx neo4j.Transaction) (interface{}, error) {
		result, err := tx.Run(`
			CREATE (u:App {
				appId: randomUuid(),
				name: $name,
				stage: $stage,
				environment: $environment,
				shortName: $shortName
			})
			RETURN u { .appId, .name } as u`,
			map[string]interface{}{
				"name":     app.Name,
				"stage":     app.Stage,
				"environment":     app.Environment,
				"shortName":     app.ShortName,
			})
		
		// Extract safe properties from the user node (`u`) in the first row
		record, err := result.Single()
		
		// Handle Unique constraint errors in the database
		if neo4jError, ok := err.(*neo4j.Neo4jError); ok && neo4jError.Title() == "ConstraintValidationFailed" {
			return nil, NewDomainError(
				AlreadyExists,
				fmt.Sprintf("An application already exists with the same name %s", app.Name),
				map[string]interface{}{
					"name": "application name taken",
				},
			)
		}
		
		// All other errors
		if err != nil {
			return nil, err
		}
		
		app, _ := record.Get("u")
		return app, nil
	})
	if err != nil {
		return retApp, err
	}
	
	retApp = getApp(result.(map[string]interface{}))
	return retApp, nil
}

// FindAll should return a paginated list of resources ordered by the `sort`
// parameter and limited to the number passed as `limit`.  The `skip` variable should be
// used to skip a certain number of rows.
//
func (ms *neo4jAppService) FindAll(page *Paging) (_ []App, err error) {
	// Open a new Session
	session := ms.driver.NewSession(neo4j.SessionConfig{})
	
	// Close the session once this function has completed
	defer func() {
		err = DeferredClose(session, err)
	}()
	
	// Execute a query in a new Read Transaction
	results, err := session.ReadTransaction(func(tx neo4j.Transaction) (interface{}, error) {
		
		// Retrieve a list of resources
		sort := page.Sort()
		result, err := tx.Run(fmt.Sprintf(`
			MATCH (m:App)
			WHERE m.`+"`%[1]s`"+` IS NOT NULL
			RETURN m { .* } AS app
			ORDER BY m.`+"`%[1]s`"+` %s
			SKIP $skip
			LIMIT $limit
		`, sort, page.Order()), map[string]interface{}{
			"skip":      page.Skip(),
			"limit":     page.Limit(),
		})
		if err != nil {
			return nil, err
		}
		
		// Get a list of Resources from the Result
		records, err := result.Collect()
		if err != nil {
			return nil, err
		}
		var results []App
		for _, record := range records {
			app, _ := record.Get("app")
			results = append(results, getApp(app.(map[string]interface{})))
		}
		return results, nil
	})
	
	if err != nil {
		return nil, err
	}
	return results.([]App), nil
}

// FindOneByName should find an App node in the database with the name
// provided by the caller
//
func (as *neo4jAppService) FindOneByName(name string) (_ App, err error) {
	// Open a new Session
	session := as.driver.NewSession(neo4j.SessionConfig{})
	defer func() {
		err = DeferredClose(session, err)
	}()
	
	// Find the App node within a Read Transaction
	result, err := session.ReadTransaction(func(tx neo4j.Transaction) (interface{}, error) {
		result, err := tx.Run(`
			MATCH (u:App {name: $name}) RETURN u`,
			map[string]interface{}{
				"name": name,
			})
		if err != nil {
			return nil, err
		}
		
		record, err := result.Single()
		if neo4jError, ok := err.(*neo4j.UsageError); ok && neo4jError.Message == "Result contains no more records" {
			return nil, NewDomainError(
				NotFound,
				fmt.Sprintf("Application with name %s not found", name),
				map[string]interface{}{
					"name": "application not found",
				},
			)
		}
		
		user, _ := record.Get("u")
		return user, nil
		
	})
	
	if err != nil {
		return App{}, err
	}
	
	appNode := result.(neo4j.Node)

	return getApp(appNode.Props), nil
}






