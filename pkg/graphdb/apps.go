package graphdb

import (
"fmt"

"github.com/neo4j/neo4j-go-driver/v4/neo4j"

)

type App map[string]interface{}

type AppService interface {
	Save(name string) (App, error)
	FindAll(page *Paging) ([]App, error)
	FindOneByName(name string) (App, error)
}

type neo4jAppService struct {
	driver     neo4j.Driver
	jwtSecret  string
	saltRounds int
}

func NewAppService(driver neo4j.Driver) AppService {
	return &neo4jAppService{
		driver:     driver,
	}
}

// Save should create a new App node in the database with the name
// provided and a `appId` property generated by the server.
//
func (as *neo4jAppService) Save(name string) (_ App, err error) {
	if err != nil {
		return nil, err
	}
	
	// Open a new Session
	session := as.driver.NewSession(neo4j.SessionConfig{})
	defer func() {
		err = DeferredClose(session, err)
	}()
	
	result, err := session.WriteTransaction(func(tx neo4j.Transaction) (interface{}, error) {
		result, err := tx.Run(`
			CREATE (u:App {
				  appId: randomUuid(),
				  name: $name
			})
			RETURN u { .appId, .name, .name } as u`,
			map[string]interface{}{
				"name":     name,
			})
		
		// Extract safe properties from the user node (`u`) in the first row
		record, err := result.Single()
		
		// Handle Unique constraint errors in the database
		if neo4jError, ok := err.(*neo4j.Neo4jError); ok && neo4jError.Title() == "ConstraintValidationFailed" {
			return nil, NewDomainError(
				AlreadyExists,
				fmt.Sprintf("An application already exists with the same name %s", name),
				map[string]interface{}{
					"name": "application name taken",
				},
			)
		}
		
		// All other errors
		if err != nil {
			return nil, err
		}
		
		app, _ := record.Get("u")
		return app, nil
	})
	if err != nil {
		return nil, err
	}
	
	app := result.(map[string]interface{})
	return app, nil
}

// FindAll should return a paginated list of resources ordered by the `sort`
// parameter and limited to the number passed as `limit`.  The `skip` variable should be
// used to skip a certain number of rows.
//
func (ms *neo4jAppService) FindAll(page *Paging) (_ []App, err error) {
	// Open a new Session
	session := ms.driver.NewSession(neo4j.SessionConfig{})
	
	// Close the session once this function has completed
	defer func() {
		err = DeferredClose(session, err)
	}()
	
	// Execute a query in a new Read Transaction
	results, err := session.ReadTransaction(func(tx neo4j.Transaction) (interface{}, error) {
		
		// Retrieve a list of resources
		sort := page.Sort()
		result, err := tx.Run(fmt.Sprintf(`
	MATCH (m:App)
	WHERE m.`+"`%[1]s`"+` IS NOT NULL
	RETURN m { .* } AS app
	ORDER BY m.`+"`%[1]s`"+` %s
	SKIP $skip
	LIMIT $limit
	`, sort, page.Order()), map[string]interface{}{
			"skip":      page.Skip(),
			"limit":     page.Limit(),
		})
		if err != nil {
			return nil, err
		}
		
		// Get a list of Resources from the Result
		records, err := result.Collect()
		if err != nil {
			return nil, err
		}
		var results []map[string]interface{}
		for _, record := range records {
			resource, _ := record.Get("app")
			results = append(results, resource.(map[string]interface{}))
		}
		return results, nil
	})
	
	if err != nil {
		return nil, err
	}
	return results.([]App), nil
}

// FindOneByName should find an App node in the database with the name
// provided by the caller
//
func (as *neo4jAppService) FindOneByName(name string) (_ App, err error) {
	// Open a new Session
	session := as.driver.NewSession(neo4j.SessionConfig{})
	defer func() {
		err = DeferredClose(session, err)
	}()
	
	// Find the App node within a Read Transaction
	result, err := session.ReadTransaction(func(tx neo4j.Transaction) (interface{}, error) {
		result, err := tx.Run(`
			MATCH (u:App {name: $name}) RETURN u`,
			map[string]interface{}{
				"name": name,
			})
		if err != nil {
			return nil, err
		}
		
		record, err := result.Single()
		if neo4jError, ok := err.(*neo4j.UsageError); ok && neo4jError.Message == "Result contains no more records" {
			return nil, NewDomainError(
				NotFound,
				fmt.Sprintf("Application with name %s not found", name),
				map[string]interface{}{
					"name": "application not found",
				},
			)
		}
		
		user, _ := record.Get("u")
		return user, nil
		
	})
	
	if err != nil {
		return nil, err
	}
	
	appNode := result.(neo4j.Node)
	app := appNode.Props

	return app, nil
}






