package graphdb

import (
	"fmt"

	"github.com/neo4j/neo4j-go-driver/v4/neo4j"
)

type App struct {
	AppId       string
	Name        string
	Stage       string
	Environment string
	ShortName   string
}

type AppService interface {
	Save(app App) (App, error)
	FindAll(page *Paging) ([]App, error)
	FindOneByName(name string) (App, error)
	QueryAppResources(stage, env, app string) ([][]string, error)
}

type neo4jAppService struct {
	driver neo4j.Driver
}

func NewAppService(driver neo4j.Driver) AppService {
	return &neo4jAppService{
		driver: driver,
	}
}
func resolveString(s interface{}) string {
	if str, ok := s.(string); ok {
		return str
	}
	return ""
}
func getApp(app map[string]interface{}) App {
	retApp := App{}
	retApp.AppId = resolveString(app["appId"])
	retApp.Name = resolveString(app["name"])
	retApp.Stage = resolveString(app["stage"])
	retApp.Environment = resolveString(app["environment"])
	retApp.ShortName = resolveString(app["shortName"])
	return retApp
}

func getAppShortName(app map[string]interface{}) string {
	return resolveString(app["shortName"])
}

// Save should create a new App node in the database with the name
// provided and a `appId` property generated by the server.
//
func (as *neo4jAppService) Save(app App) (_ App, err error) {
	retApp := App{}

	// Open a new Session
	session := as.driver.NewSession(neo4j.SessionConfig{})
	defer func() {
		err = DeferredClose(session, err)
	}()

	result, err := session.WriteTransaction(func(tx neo4j.Transaction) (interface{}, error) {
		result, err := tx.Run(`
			CREATE (u:App {
				appId: randomUuid(),
				name: $name,
				stage: $stage,
				environment: $environment,
				shortName: $shortName
			})
			RETURN u { .appId, .name } as u`,
			map[string]interface{}{
				"name":        app.Name,
				"stage":       app.Stage,
				"environment": app.Environment,
				"shortName":   app.ShortName,
			})

		// Extract safe properties from the user node (`u`) in the first row
		record, err := result.Single()

		// Handle Unique constraint errors in the database
		if neo4jError, ok := err.(*neo4j.Neo4jError); ok && neo4jError.Title() == "ConstraintValidationFailed" {
			return nil, NewDomainError(
				AlreadyExists,
				fmt.Sprintf("An application already exists with the same name %s", app.Name),
				map[string]interface{}{
					"name": "application name taken",
				},
			)
		}

		// All other errors
		if err != nil {
			return nil, err
		}

		app, _ := record.Get("u")
		return app, nil
	})
	if err != nil {
		return retApp, err
	}

	retApp = getApp(result.(map[string]interface{}))
	return retApp, nil
}

// FindAll should return a paginated list of resources ordered by the `sort`
// parameter and limited to the number passed as `limit`.  The `skip` variable should be
// used to skip a certain number of rows.
//
func (ms *neo4jAppService) FindAll(page *Paging) (_ []App, err error) {
	// Open a new Session
	session := ms.driver.NewSession(neo4j.SessionConfig{})

	// Close the session once this function has completed
	defer func() {
		err = DeferredClose(session, err)
	}()

	// Execute a query in a new Read Transaction
	results, err := session.ReadTransaction(func(tx neo4j.Transaction) (interface{}, error) {

		// Retrieve a list of resources
		sort := page.Sort()
		result, err := tx.Run(fmt.Sprintf(`
			MATCH (m:App)
			WHERE m.`+"`%[1]s`"+` IS NOT NULL
			RETURN m { .* } AS app
			ORDER BY m.`+"`%[1]s`"+` %s
			SKIP $skip
			LIMIT $limit
		`, sort, page.Order()), map[string]interface{}{
			"skip":  page.Skip(),
			"limit": page.Limit(),
		})
		if err != nil {
			return nil, err
		}

		// Get a list of Resources from the Result
		records, err := result.Collect()
		if err != nil {
			return nil, err
		}
		var results []App
		for _, record := range records {
			app, _ := record.Get("app")
			results = append(results, getApp(app.(map[string]interface{})))
		}
		return results, nil
	})

	if err != nil {
		return nil, err
	}
	return results.([]App), nil
}

// FindOneByName should find an App node in the database with the name
// provided by the caller
//
func (as *neo4jAppService) FindOneByName(name string) (_ App, err error) {
	// Open a new Session
	session := as.driver.NewSession(neo4j.SessionConfig{})
	defer func() {
		err = DeferredClose(session, err)
	}()

	// Find the App node within a Read Transaction
	result, err := session.ReadTransaction(func(tx neo4j.Transaction) (interface{}, error) {
		result, err := tx.Run(`
			MATCH (u:App {name: $name}) RETURN u`,
			map[string]interface{}{
				"name": name,
			})
		if err != nil {
			return nil, err
		}

		record, err := result.Single()
		if neo4jError, ok := err.(*neo4j.UsageError); ok && neo4jError.Message == "Result contains no more records" {
			return nil, NewDomainError(
				NotFound,
				fmt.Sprintf("Application with name %s not found", name),
				map[string]interface{}{
					"name": "application not found",
				},
			)
		}

		user, _ := record.Get("u")
		return user, nil

	})

	if err != nil {
		return App{}, err
	}

	appNode := result.(neo4j.Node)

	return getApp(appNode.Props), nil
}

// QueryAppResources should find resources and relations for an App
// depending on the stage and env parameters more than one application can
// be returned to the caller in the collection result
//
func (as *neo4jAppService) QueryAppResources(stage, env, app string) (result [][]string, err error) {
	// Open a new Session
	session := as.driver.NewSession(neo4j.SessionConfig{})
	defer func() {
		err = DeferredClose(session, err)
	}()

	// Create Query pattern
	stageMatch := ""
	if len(stage) > 0 {
		stageMatch = ", stage: $stage"
	}

	envMatch := ""
	if len(env) > 0 {
		envMatch = ", environment: $environment"
	}

	cypher := "MATCH (app:App {shortName: $shortName" + envMatch + stageMatch + "})-[r]->(resource) RETURN app,r,resource"
	// Find the App node within a Read Transaction
	records, err := session.ReadTransaction(func(tx neo4j.Transaction) (interface{}, error) {
		result, err := tx.Run(cypher,
			map[string]interface{}{
				"stage":       stage,
				"environment": env,
				"shortName":   app,
			})
		if err != nil {
			return nil, err
		}

		// Get a list of Resources from the Result
		records, err := result.Collect()
		if err != nil {
			return nil, err
		}
		//var results []map[string]interface{}
		//keys := []string{
		//	"app",
		//	"relation",
		//	"resource",
		//}
		// The returned result is pretty detailed (App)-[ACCESS]->(Resource)
		// We trim it down for now for the report we want but can always add
		// more detail if desired.
		//for _, record := range records {
		//	values := map[string]interface{}{}
		//	for i, v := range record.Values {
		//		values[keys[i]] = v
		//	}
		//	results = append(results, values)
		//}

		report := [][]string{}
		for _, record := range records {
			appRes := App{}
			if a, ok := record.Get("app"); ok {
				if n, ok := a.(neo4j.Node); ok {
					appRes = getApp(n.Props)
				}
			}
			resourceName := ""
			resourceKind := ""
			if res, ok := record.Get("resource"); ok {
				if n, ok := res.(neo4j.Node); ok {
					resourceKind = getResourceKind(n.Props)
					resourceName = getResourceName(n.Props)
				}
			}
			e := []string{
				appRes.Stage,
				appRes.Environment,
				appRes.ShortName,
				resourceKind,
				resourceName,
			}
			report = append(report, e)
		}

		return report, nil
	})

	if result, ok := records.([][]string); ok {
		return result, nil
	}

	return [][]string{}, nil
}
