package graphdb

import (
	"fmt"
	"github.com/neo4j/neo4j-go-driver/v4/neo4j"
)

type Claim = map[string]interface{}

type ClaimService interface {
	Save(name string) (Claim, error)
	SaveRelation(access Access, appId, claimId string) (Resource, error)
	FindAll(page *Paging) ([]Claim, error)
	GetAppClaims(appId string) ([]Claim, error)
	FindOneByName(name string) (Claim, error)
}

type neo4jClaimService struct {
	driver neo4j.Driver
}

func getClaimName(app map[string]interface{}) string {
	return resolveString(app["name"])
}

func NewClaimService(driver neo4j.Driver) ClaimService {
	return &neo4jClaimService{driver: driver}
}

// Save should create a new Claim node in the database with the name
// provided and a `claimId` property generated by the server.
//

func (as *neo4jClaimService) Save(name string) (_ Claim, err error) {
	// Open a new Session
	session := as.driver.NewSession(neo4j.SessionConfig{})
	defer func() {
		err = DeferredClose(session, err)
	}()

	result, err := session.WriteTransaction(func(tx neo4j.Transaction) (interface{}, error) {
		result, err := tx.Run(`
			CREATE (u:Claim {
				  claimId: randomUuid(),
				  name: $name
			})
			RETURN u { .claimId, .name } as u`,
			map[string]interface{}{
				"name": name,
			})

		// Extract safe properties from the user node (`u`) in the first row
		record, err := result.Single()

		// Handle Unique constraint errors in the database
		if neo4jError, ok := err.(*neo4j.Neo4jError); ok && neo4jError.Title() == "ConstraintValidationFailed" {
			return nil, NewDomainError(
				AlreadyExists,
				fmt.Sprintf("A claim already exists with the same name %s", name),
				map[string]interface{}{
					"name": "claim name taken",
				},
			)
		}

		// All other errors
		if err != nil {
			return nil, err
		}

		claim, _ := record.Get("u")
		return claim, nil
	})
	if err != nil {
		return nil, err
	}

	claim := result.(map[string]interface{})
	return claim, nil
}

// FindAll should return a paginated list of claims ordered by the `sort`
// parameter and limited to the number passed as `limit`.  The `skip` variable should be
// used to skip a certain number of rows.
//
func (ms *neo4jClaimService) FindAll(page *Paging) (_ []Claim, err error) {
	// Open a new Session
	session := ms.driver.NewSession(neo4j.SessionConfig{})

	// Close the session once this function has completed
	defer func() {
		err = DeferredClose(session, err)
	}()

	// Execute a query in a new Read Transaction
	results, err := session.ReadTransaction(func(tx neo4j.Transaction) (interface{}, error) {

		// Retrieve a list of claims
		sort := page.Sort()
		result, err := tx.Run(fmt.Sprintf(`
	MATCH (m:Claim)
	WHERE m.`+"`%[1]s`"+` IS NOT NULL
	RETURN m { .* } AS claim
	ORDER BY m.`+"`%[1]s`"+` %s
	SKIP $skip
	LIMIT $limit
	`, sort, page.Order()), map[string]interface{}{
			"skip":  page.Skip(),
			"limit": page.Limit(),
		})
		if err != nil {
			return nil, err
		}

		// Get a list of Claims from the Result
		records, err := result.Collect()
		if err != nil {
			return nil, err
		}
		var results []map[string]interface{}
		for _, record := range records {
			claim, _ := record.Get("claim")
			results = append(results, claim.(map[string]interface{}))
		}
		return results, nil
	})

	if err != nil {
		return nil, err
	}
	return results.([]Claim), nil
}

// getAppClaims should return a list of claims that have
// the app has added to their Claims Access list.
func (ms *neo4jClaimService) GetAppClaims(appId string) (_ []Claim, err error) {

	// Open a new Session
	session := ms.driver.NewSession(neo4j.SessionConfig{})

	// Close the session once this function has completed
	defer func() {
		err = DeferredClose(session, err)
	}()

	// Execute a query in a new Read Transaction
	results, err := session.ReadTransaction(func(tx neo4j.Transaction) (interface{}, error) {
		// If appId is not defined, return nil
		if appId == "" {
			return nil, nil
		}

		// Find Claims for App
		result, err := tx.Run(`
		MATCH (u:App {appId: $appId})-[:ACCESS]->(m)
		RETURN m { .* } AS claim
	`, map[string]interface{}{"appId": appId})

		if err != nil {
			return nil, err
		}

		// Get a list of Claims from the Result
		records, err := result.Collect()
		if err != nil {
			return nil, err
		}
		var results []map[string]interface{}
		for _, record := range records {
			claim, _ := record.Get("claim")
			results = append(results, claim.(map[string]interface{}))
		}
		return results, nil
	})

	if err != nil {
		return nil, err
	}
	return results.([]Claim), nil
}

// FindOneByName should find an Claim node in the database with the name
// provided by the caller
//
func (as *neo4jClaimService) FindOneByName(name string) (_ Claim, err error) {
	// Open a new Session
	session := as.driver.NewSession(neo4j.SessionConfig{})
	defer func() {
		err = DeferredClose(session, err)
	}()

	// Find the Claim node within a Read Transaction
	result, err := session.ReadTransaction(func(tx neo4j.Transaction) (interface{}, error) {
		result, err := tx.Run(`
			MATCH (u:Claim {name: $name}) RETURN u`,
			map[string]interface{}{
				"name": name,
			})
		if err != nil {
			return nil, err
		}

		record, err := result.Single()
		if neo4jError, ok := err.(*neo4j.UsageError); ok && neo4jError.Message == "Result contains no more records" {
			return nil, NewDomainError(
				NotFound,
				fmt.Sprintf("Claim with name %s not found", name),
				map[string]interface{}{
					"name": "claim not found",
				},
			)
		}

		if err != nil {
			return nil, err
		}

		claim, _ := record.Get("u")
		return claim, nil

	})

	if err != nil {
		return nil, err
	}

	claimNode := result.(neo4j.Node)
	claim := claimNode.Props

	return claim, nil
}

// If the App or Resource cannot be found, a NotFoundError should be thrown
func (fs *neo4jClaimService) SaveRelation(access Access, appId, claimId string) (_ Claim, err error) {
	// Open a new session
	session := fs.driver.NewSession(neo4j.SessionConfig{})
	defer func() {
		err = DeferredClose(session, err)
	}()

	// Save the rating in the database
	result, err := session.WriteTransaction(func(tx neo4j.Transaction) (interface{}, error) {
		result, err := tx.Run(`
				MATCH (u:App {appId: $appId})
				MATCH (m:Claim {claimId: $claimId})

				MERGE (u)-[r:CLAIM]->(m)
				SET r.timestamp = timestamp()

				RETURN m { .* } AS claim
		`, map[string]interface{}{
			"appId":   appId,
			"claimId": claimId,
		})

		// Handle error from driver
		if err != nil {
			return nil, err
		}

		// Get the one and only record
		record, err := result.Single()
		if err != nil {
			return nil, err
		}

		// Extract resource properties
		claim, _ := record.Get("claim")
		return claim.(map[string]interface{}), nil
	})

	// Handle Errors from the Unit of Work
	if err != nil {
		return nil, err
	}

	// Return resource details and access properties
	return result.(Claim), nil
}
